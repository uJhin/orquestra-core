:py:mod:`integrations.qiskit.simulator`
=======================================

.. py:module:: integrations.qiskit.simulator


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   simulator/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   integrations.qiskit.simulator.QiskitSimulator




.. py:class:: QiskitSimulator(device_name: str, noise_model: Optional[qiskit.providers.aer.noise.NoiseModel] = None, device_connectivity: Optional[orquestra.quantum.circuits.layouts.CircuitConnectivity] = None, basis_gates: Optional[List] = None, api_token: Optional[str] = None, optimization_level: int = 0, seed: Optional[int] = None, **kwargs)

   Bases: :py:obj:`orquestra.quantum.api.backend.QuantumSimulator`

   Simulator capable of computing exact wavefunction.

   Note that in contrast to non-simulator QuantumBackends, simulators
   are capable of simulating operations that are not natively supported
   by libraries/services they wrap. Therefore, simulation of a circuit may
   get broken into several smaller circuits. Each native circuit run
   using the wrapped library or service counts towards number_of_circuits
   run and number_of_jobs_run. However, if simulated circuit comprises only
   natively supported operation AND concrete implementation does not change
   counting methodology, each simulated circuit corresponds to an increase
   of both those numbers by one.

   .. py:attribute:: supports_batching
      :annotation: = False

      

   .. py:attribute:: batch_size
      

      

   .. py:method:: get_device(self, noisy=False, **kwargs)

      Get the ibm device used for executing circuits

      :param noisy: a boolean indicating if the user wants to use noisy
                    simulations
      :type noisy: bool

      :returns: The ibm device that can use the ibm execute api


   .. py:method:: run_circuit_and_measure(self, circuit: orquestra.quantum.circuits.Circuit, n_samples: int) -> orquestra.quantum.measurements.Measurements

      Run a circuit and measure a certain number of bitstrings. Note: the
      number of bitstrings measured is derived from self.n_samples

      :param circuit: the circuit to prepare the state
      :param n_samples: The number of samples to collect.




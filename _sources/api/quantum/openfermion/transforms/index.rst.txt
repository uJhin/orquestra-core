:py:mod:`quantum.openfermion.transforms`
========================================

.. py:module:: quantum.openfermion.transforms


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   opconversions/index.rst
   repconversions/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   quantum.openfermion.transforms.check_no_sympy
   quantum.openfermion.transforms.chemist_ordered
   quantum.openfermion.transforms.get_fermion_operator
   quantum.openfermion.transforms.jordan_wigner_one_body
   quantum.openfermion.transforms.jordan_wigner_two_body
   quantum.openfermion.transforms.normal_ordered
   quantum.openfermion.transforms.normal_ordered_ladder_term
   quantum.openfermion.transforms.reorder
   quantum.openfermion.transforms.freeze_orbitals
   quantum.openfermion.transforms.get_interaction_operator
   quantum.openfermion.transforms.get_molecular_data
   quantum.openfermion.transforms.prune_unused_indices



.. py:function:: check_no_sympy(operator)

   Checks whether a SymbolicOperator contains any
   sympy expressions, which will prevent it being converted
   to a PolynomialTensor

   :param operator: the operator to be tested
   :type operator: SymbolicOperator


.. py:function:: chemist_ordered(fermion_operator)

   Puts a two-body fermion operator in chemist ordering.

   The normal ordering convention for chemists is different.
   Rather than ordering the two-body term as physicists do, as
   $a^\dagger a^\dagger a a$
   the chemist ordering of the two-body term is
   $a^\dagger a a^\dagger a$

   TODO: This routine can be made more efficient.

   :param fermion_operator: a fermion operator guarenteed to
                            have number conserving one- and two-body fermion terms only.
   :type fermion_operator: FermionOperator

   :returns:

             the input operator
                 ordered in the chemistry convention.
   :rtype: chemist_ordered_operator (FermionOperator)

   :raises OperatorSpecificationError: Operator is not two-body number conserving.


.. py:function:: get_fermion_operator(operator)

   Convert to FermionOperator.

   :returns: An instance of the FermionOperator class.
   :rtype: fermion_operator


.. py:function:: jordan_wigner_one_body(p, q, coefficient=1.0)

   Map the term a^\dagger_p a_q + h.c. to QubitOperator.

   Note that the diagonal terms are divided by a factor of 2
   because they are equal to their own Hermitian conjugate.


.. py:function:: jordan_wigner_two_body(p, q, r, s, coefficient=1.0)

   Map the term a^\dagger_p a^\dagger_q a_r a_s + h.c. to QubitOperator.

   Note that the diagonal terms are divided by a factor of two
   because they are equal to their own Hermitian conjugate.


.. py:function:: normal_ordered(operator, hbar=1.0)

   Compute and return the normal ordered form of a FermionOperator,
   or InteractionOperator.

   Due to the canonical commutation/anticommutation relations satisfied
   by these operators, there are multiple forms that the same operator
   can take. Here, we define the normal ordered form of each operator,
   providing a distinct representation for distinct operators.

   In our convention, normal ordering implies terms are ordered
   from highest tensor factor (on left) to lowest (on right). In
   addition:

   * FermionOperators: a^\dagger comes before a

   :param operator: an instance of the FermionOperator, or InteractionOperator classes.
   :param hbar: the value of hbar used in the definition of the
                commutator [q_i, p_j] = i hbar delta_ij. By default hbar=1.
   :type hbar: float


.. py:function:: normal_ordered_ladder_term(term, coefficient, parity=-1)

   Return a normal ordered FermionOperator corresponding
   to single term.

   :param term: A sequence of tuples. The first element of each
                tuple is an integer indicating the mode on which a fermion ladder
                operator acts, starting from zero. The second element of each
                tuple is an integer, either 1 or 0, indicating whether creation
                or annihilation acts on that mode.
   :type term: list or tuple
   :param coefficient: The coefficient of the term.
   :type coefficient: complex or float
   :param parity: parity=-1 corresponds to a Fermionic term that should be
                  ordered based on the canonical anti-commutation relations.
                  parity=1 corresponds to a Bosonic term that should be ordered based
                  on the canonical commutation relations.
   :type parity: int

   :returns:

             a FermionOperator instance.
                 The normal ordered form of the input.
                 Note that this might have more terms.
   :rtype: ordered_term

   In our convention, normal ordering implies terms are ordered
   from highest tensor factor (on left) to lowest (on right).
   Also, ladder operators come first.

   .. warning::

      Even assuming that each creation or annihilation operator appears
      at most a constant number of times in the original term, the
      runtime of this method is exponential in the number of qubits.


.. py:function:: reorder(operator, order_function, num_modes=None, reverse=False)

   Changes the ladder operator order of the Hamiltonian based on the
   provided order_function per mode index.

   :param operator: the operator that will be reordered. must
                    be a SymbolicOperator or any type of operator that inherits from
                    SymbolicOperator.
   :type operator: SymbolicOperator
   :param order_function: a function per mode that is used to map the
                          indexing. must have arguments mode index and num_modes.
   :type order_function: func
   :param num_modes: default None. User can provide the number of modes
                     assumed for the system. if None, the number of modes will be
                     calculated based on the Operator.
   :type num_modes: int
   :param reverse: default False. if set to True, the mode mapping is
                   reversed. reverse = True will not revert back to original if
                   num_modes calculated differs from original and reverted.
   :type reverse: bool

   Note: Every order function must take in a mode_idx and num_modes.


.. py:function:: freeze_orbitals(fermion_operator, occupied, unoccupied=None, prune=True)

   Fix some orbitals to be occupied and others unoccupied.

   Removes all operators acting on the specified orbitals, and renumbers the
   remaining orbitals to eliminate unused indices. The sign of each term
   is modified according to the ladder uperator anti-commutation relations in
   order to preserve the expectation value of the operator.

   :param occupied: A list containing the indices of the orbitals that are to be
                    assumed to be occupied.
   :param unoccupied: A list containing the indices of the orbitals that are to
                      be assumed to be unoccupied.


.. py:function:: get_interaction_operator(fermion_operator, n_qubits=None)

   Convert a 2-body fermionic operator to InteractionOperator.

   This function should only be called on fermionic operators which
   consist of only a_p^\dagger a_q and a_p^\dagger a_q^\dagger a_r a_s
   terms. The one-body terms are stored in a matrix, one_body[p, q], and
   the two-body terms are stored in a tensor, two_body[p, q, r, s].

   :returns: An instance of the InteractionOperator class.
   :rtype: interaction_operator

   :raises TypeError: Input must be a FermionOperator.
   :raises TypeError: FermionOperator does not map to InteractionOperator.

   .. warning::

      Even assuming that each creation or annihilation operator appears
      at most a constant number of times in the original operator, the
      runtime of this method is exponential in the number of qubits.


.. py:function:: get_molecular_data(interaction_operator, geometry=None, basis=None, multiplicity=None, n_electrons=None, reduce_spin=True, data_directory=None)

   Output a MolecularData object generated from an InteractionOperator

   :param interaction_operator: two-body interaction
                                operator defining the "molecular interaction" to be simulated.
   :type interaction_operator: InteractionOperator
   :param geometry:
   :type geometry: string or list of atoms
   :param basis: String denoting the basis set used to discretize the
                 system.
   :type basis: string
   :param multiplicity: Spin multiplicity desired in the system.
   :type multiplicity: int
   :param n_electrons: Number of electrons in the system
   :type n_electrons: int
   :param reduce_spin: True if one wishes to perform spin reduction on
                       integrals that are given in interaction operator.  Assumes
                       spatial (x) spin structure generically.
   :type reduce_spin: bool

   :returns:     Instance that captures the
                 interaction_operator converted into the format that would come
                 from an electronic structure package adorned with some meta-data
                 that may be useful.
   :rtype: molecule(MolecularData)


.. py:function:: prune_unused_indices(symbolic_operator)

   Remove indices that do not appear in any terms.

   Indices will be renumbered such that if an index i does not appear in
   any terms, then the next largest index that appears in at least one
   term will be renumbered to i.


